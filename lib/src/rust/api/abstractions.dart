// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.7.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are not used by any `pub` functions: `ProbSpace`, `SEGn`, `XYWH`, `XYXY`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`

/// Bounding box in normalized XYWH format
/// # Fields
/// - `x` and `y` represent the center
/// - `w` and `h` represent width and height
class XYWHn {
  final double x;
  final double y;
  final double w;
  final double h;
  final BigInt classId;
  final double probability;

  const XYWHn({
    required this.x,
    required this.y,
    required this.w,
    required this.h,
    required this.classId,
    required this.probability,
  });

  Future<double> area() => RustLib.instance.api.crateApiAbstractionsXywHnArea(
        that: this,
      );

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<XYWHn> newInstance(
          {required double x,
          required double y,
          required double w,
          required double h,
          required BigInt classId,
          required double probability}) =>
      RustLib.instance.api.crateApiAbstractionsXywHnNew(
          x: x, y: y, w: w, h: h, classId: classId, probability: probability);

  Future<XYXYn> toxyxy() =>
      RustLib.instance.api.crateApiAbstractionsXywHnToxyxy(
        that: this,
      );

  @override
  int get hashCode =>
      x.hashCode ^
      y.hashCode ^
      w.hashCode ^
      h.hashCode ^
      classId.hashCode ^
      probability.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is XYWHn &&
          runtimeType == other.runtimeType &&
          x == other.x &&
          y == other.y &&
          w == other.w &&
          h == other.h &&
          classId == other.classId &&
          probability == other.probability;
}

/// Bounding box in normalized XYXY format
/// # Fields
/// - `x1` and `y1` represent the top-left corner
/// - `x2` and `y2` represent the bottom-right  corner
class XYXYn {
  final double x1;
  final double y1;
  final double x2;
  final double y2;
  final BigInt classId;
  final double probability;

  const XYXYn({
    required this.x1,
    required this.y1,
    required this.x2,
    required this.y2,
    required this.classId,
    required this.probability,
  });

  Future<double> area() => RustLib.instance.api.crateApiAbstractionsXyxYnArea(
        that: this,
      );

  Future<double> intersect({required XYXYn other}) => RustLib.instance.api
      .crateApiAbstractionsXyxYnIntersect(that: this, other: other);

  Future<double> iou({required XYXYn other}) => RustLib.instance.api
      .crateApiAbstractionsXyxYnIou(that: this, other: other);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<XYXYn> newInstance(
          {required double x1,
          required double y1,
          required double x2,
          required double y2,
          required BigInt classId,
          required double probability}) =>
      RustLib.instance.api.crateApiAbstractionsXyxYnNew(
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2,
          classId: classId,
          probability: probability);

  Future<XYWHn> toxywh() =>
      RustLib.instance.api.crateApiAbstractionsXyxYnToxywh(
        that: this,
      );

  @override
  int get hashCode =>
      x1.hashCode ^
      y1.hashCode ^
      x2.hashCode ^
      y2.hashCode ^
      classId.hashCode ^
      probability.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is XYXYn &&
          runtimeType == other.runtimeType &&
          x1 == other.x1 &&
          y1 == other.y1 &&
          x2 == other.x2 &&
          y2 == other.y2 &&
          classId == other.classId &&
          probability == other.probability;
}
