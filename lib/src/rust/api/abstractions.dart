// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.7.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `intersect_xywhs`, `intersect_xyxys`, `iou`, `nms`
// These types are ignored because they are not used by any `pub` functions: `PredImg`, `ProbSpace`, `SEGn`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`
// These functions are ignored (category: IgnoreBecauseSelfTypeNotAllowed): `intersect`, `iou`

abstract class BoundingBox {
  Future<double> area();

  Future<BigInt> getClassId();

  Future<double> getProb();
}

/// Bounding box in normalized XYWH format
/// # Fields
/// - `x` and `y` represent the center
/// - `w` and `h` represent width and height
class XYWHn {
  final double x;
  final double y;
  final double w;
  final double h;
  final BigInt classId;
  final double prob;

  const XYWHn({
    required this.x,
    required this.y,
    required this.w,
    required this.h,
    required this.classId,
    required this.prob,
  });

  Future<double> area() => RustLib.instance.api.crateApiAbstractionsXywHnArea(
        that: this,
      );

  Future<BigInt> getClassId() =>
      RustLib.instance.api.crateApiAbstractionsXywHnGetClassId(
        that: this,
      );

  Future<double> getProb() =>
      RustLib.instance.api.crateApiAbstractionsXywHnGetProb(
        that: this,
      );

  Future<double> intersect({required XYWHn other}) => RustLib.instance.api
      .crateApiAbstractionsXywHnIntersect(that: this, other: other);

  Future<double> iou({required XYWHn other}) => RustLib.instance.api
      .crateApiAbstractionsXywHnIou(that: this, other: other);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<XYWHn> newInstance(
          {required double x,
          required double y,
          required double w,
          required double h,
          required BigInt classId,
          required double prob}) =>
      RustLib.instance.api.crateApiAbstractionsXywHnNew(
          x: x, y: y, w: w, h: h, classId: classId, prob: prob);

  Future<XYXYn> toxyxyn() =>
      RustLib.instance.api.crateApiAbstractionsXywHnToxyxyn(
        that: this,
      );

  @override
  int get hashCode =>
      x.hashCode ^
      y.hashCode ^
      w.hashCode ^
      h.hashCode ^
      classId.hashCode ^
      prob.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is XYWHn &&
          runtimeType == other.runtimeType &&
          x == other.x &&
          y == other.y &&
          w == other.w &&
          h == other.h &&
          classId == other.classId &&
          prob == other.prob;
}

class XYWH {
  final double x;
  final double y;
  final double w;
  final double h;
  final BigInt classId;
  final double prob;

  const XYWH({
    required this.x,
    required this.y,
    required this.w,
    required this.h,
    required this.classId,
    required this.prob,
  });

  Future<double> area() => RustLib.instance.api.crateApiAbstractionsXywhArea(
        that: this,
      );

  Future<BigInt> getClassId() =>
      RustLib.instance.api.crateApiAbstractionsXywhGetClassId(
        that: this,
      );

  Future<double> getProb() =>
      RustLib.instance.api.crateApiAbstractionsXywhGetProb(
        that: this,
      );

  Future<double> intersect({required XYWH other}) => RustLib.instance.api
      .crateApiAbstractionsXywhIntersect(that: this, other: other);

  Future<double> iou({required XYWH other}) => RustLib.instance.api
      .crateApiAbstractionsXywhIou(that: this, other: other);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<XYWH> newInstance(
          {required double x,
          required double y,
          required double w,
          required double h,
          required BigInt classId,
          required double prob}) =>
      RustLib.instance.api.crateApiAbstractionsXywhNew(
          x: x, y: y, w: w, h: h, classId: classId, prob: prob);

  Future<XYXY> toxyxyn() =>
      RustLib.instance.api.crateApiAbstractionsXywhToxyxyn(
        that: this,
      );

  @override
  int get hashCode =>
      x.hashCode ^
      y.hashCode ^
      w.hashCode ^
      h.hashCode ^
      classId.hashCode ^
      prob.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is XYWH &&
          runtimeType == other.runtimeType &&
          x == other.x &&
          y == other.y &&
          w == other.w &&
          h == other.h &&
          classId == other.classId &&
          prob == other.prob;
}

/// Bounding box in normalized XYXY format
/// # Fields
/// - `x1` and `y1` represent the top-left corner
/// - `x2` and `y2` represent the bottom-right  corner
class XYXYn {
  final double x1;
  final double y1;
  final double x2;
  final double y2;
  final BigInt classId;
  final double prob;

  const XYXYn({
    required this.x1,
    required this.y1,
    required this.x2,
    required this.y2,
    required this.classId,
    required this.prob,
  });

  Future<double> area() => RustLib.instance.api.crateApiAbstractionsXyxYnArea(
        that: this,
      );

  Future<BigInt> getClassId() =>
      RustLib.instance.api.crateApiAbstractionsXyxYnGetClassId(
        that: this,
      );

  Future<double> getProb() =>
      RustLib.instance.api.crateApiAbstractionsXyxYnGetProb(
        that: this,
      );

  Future<double> intersect({required XYXYn other}) => RustLib.instance.api
      .crateApiAbstractionsXyxYnIntersect(that: this, other: other);

  Future<double> iou({required XYXYn other}) => RustLib.instance.api
      .crateApiAbstractionsXyxYnIou(that: this, other: other);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<XYXYn> newInstance(
          {required double x1,
          required double y1,
          required double x2,
          required double y2,
          required BigInt classId,
          required double prob}) =>
      RustLib.instance.api.crateApiAbstractionsXyxYnNew(
          x1: x1, y1: y1, x2: x2, y2: y2, classId: classId, prob: prob);

  Future<XYWHn> toxywhn() =>
      RustLib.instance.api.crateApiAbstractionsXyxYnToxywhn(
        that: this,
      );

  @override
  int get hashCode =>
      x1.hashCode ^
      y1.hashCode ^
      x2.hashCode ^
      y2.hashCode ^
      classId.hashCode ^
      prob.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is XYXYn &&
          runtimeType == other.runtimeType &&
          x1 == other.x1 &&
          y1 == other.y1 &&
          x2 == other.x2 &&
          y2 == other.y2 &&
          classId == other.classId &&
          prob == other.prob;
}

class XYXY {
  final double x1;
  final double y1;
  final double x2;
  final double y2;
  final BigInt classId;
  final double prob;

  const XYXY({
    required this.x1,
    required this.y1,
    required this.x2,
    required this.y2,
    required this.classId,
    required this.prob,
  });

  Future<double> area() => RustLib.instance.api.crateApiAbstractionsXyxyArea(
        that: this,
      );

  Future<BigInt> getClassId() =>
      RustLib.instance.api.crateApiAbstractionsXyxyGetClassId(
        that: this,
      );

  Future<double> getProb() =>
      RustLib.instance.api.crateApiAbstractionsXyxyGetProb(
        that: this,
      );

  Future<double> intersect({required XYXY other}) => RustLib.instance.api
      .crateApiAbstractionsXyxyIntersect(that: this, other: other);

  Future<double> iou({required XYXY other}) => RustLib.instance.api
      .crateApiAbstractionsXyxyIou(that: this, other: other);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<XYXY> newInstance(
          {required double x1,
          required double y1,
          required double x2,
          required double y2,
          required BigInt classId,
          required double prob}) =>
      RustLib.instance.api.crateApiAbstractionsXyxyNew(
          x1: x1, y1: y1, x2: x2, y2: y2, classId: classId, prob: prob);

  Future<XYWH> toxywhn() =>
      RustLib.instance.api.crateApiAbstractionsXyxyToxywhn(
        that: this,
      );

  @override
  int get hashCode =>
      x1.hashCode ^
      y1.hashCode ^
      x2.hashCode ^
      y2.hashCode ^
      classId.hashCode ^
      prob.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is XYXY &&
          runtimeType == other.runtimeType &&
          x1 == other.x1 &&
          y1 == other.y1 &&
          x2 == other.x2 &&
          y2 == other.y2 &&
          classId == other.classId &&
          prob == other.prob;
}
